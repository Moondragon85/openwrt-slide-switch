#
# src/usr/share/slide-switch/functions.sh-cut.in
# This file is part of slide-switch.
#
# Copyright (C) 2016-2019, 2022 The slide-switch authors
# https://github.com/jefferyto/openwrt-slide-switch
#
# slide-switch is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# version 2 as published by the Free Software Foundation.
#
# slide-switch is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with slide-switch.  If not, see <http://www.gnu.org/licenses/>.
#
# --8<---- CUT HERE
#
# Copyright (C) 2016-2019, 2022 The slide-switch authors
# https://github.com/jefferyto/openwrt-slide-switch
#
# slide-switch is free software, licensed under the GNU General Public License v2.
#

package=@PACKAGE@
version=@VERSION@

data_dir=@pkgdatadir@
run_dir=@localstatedir@/run/@PACKAGE@
lock_dir=@localstatedir@/lock/@PACKAGE@
initd_dir=@sysconfdir@/init.d

gpio_table=/sys/kernel/debug/gpio
hotplug_call=/sbin/hotplug-call
rc_button=/etc/rc.button

switch_data_file=$data_dir/switch-data.json
switches_cache=$run_dir/switches
state_dir=$run_dir/state
initd_script=$initd_dir/zzz-slide-switch

. /usr/share/libubox/jshn.sh

ex_usage=64
ex_dataerr=65
ex_noinput=66
ex_unavailable=69
ex_oserr=71

log_stderr=
log_syslog=
verbosity=
locks=


log_level_to_num() {
	local _var="$1"
	local _level="$2"
	local _num

	case $_level in
		emerg|panic)  _num=0 ;;
		alert)        _num=1 ;;
		crit)         _num=2 ;;
		err|error)    _num=3 ;;
		warning|warn) _num=4 ;;
		notice)       _num=5 ;;
		info)         _num=6 ;;
		debug)        _num=7 ;;

		*[!0-9]*)     return 1 ;;

		*)            _num=$_level ;;
	esac

	_set_var "$_var" "$_num"
}

log() {
	local level="$1"
	local message="$2"
	local level_num

	log_level_to_num level_num "$level" &&
	[ "$level_num" -le "$verbosity" ] || return 0

	[ -n "$log_stderr" ] && echo "[$level] $message" >&2

	[ -n "$log_syslog" ] && logger -t "${package}[$$]" -p "user.$level" "$message"

	return 0
}

error() {
	log err "$@"
}

warning() {
	log warning "$@"
}

notice() {
	log notice "$@"
}

info() {
	log info "$@"
}

debug() {
	log debug "$@"
}


board_name() {
	[ -e /tmp/sysinfo/board_name ] && cat /tmp/sysinfo/board_name || echo "generic"
}

get_epoch() {
	local _var="$1"
	local _epoch

	_epoch=$(date +%s) || {
		error "get_epoch: failed to get date"
		return $ex_oserr
	}

	_set_var "$_var" "$_epoch"
}

list_contains() {
	local list=" $1 "
	local item=" $2 "

	[ -z "${list##*$item*}" ]
}


get_gpio_info() {
	local ___var="$1"
	local ___label="$2"
	local ___row

	___row="$(grep -m 1 -e "|$___label *) in  " "$gpio_table" 2>/dev/null)" || return

	_set_var "$___var" "${___row##*)}"
}

get_gpio_value() {
	local __var="$1"
	local __label="$2"
	local __value="lo"
	local __info

	get_gpio_info __info "$__label" || {
		error "get_gpio_value: failed to get value for label \"$__label\""
		return $ex_oserr
	}

	list_contains "$__info" hi && __value=hi

	_set_var "$__var" "$__value"
}

get_position_code() {
	local _var="$1"
	local _switch="$2"
	local _position_name="$3"

	_set_var "$_var" "${_switch}-$_position_name"
}


check_json_type() {
	local key="$1"
	local type="$2"
	local key_name="${3:-$key}"
	local article="a"

	case $type in
		[aeiou]*) article=an ;;
	esac

	json_is_a "$key" "$type" || {
		error "check_json_type: \"$key_name\" is not $article $type in $switch_data_file"
		return 1
	}
}

check_input_gpio_label() {
	local label="$1"
	local info

	get_gpio_info info "$label" && [ -n "$info" ] || {
		error "check_input_gpio_label: \"$label\" is not the label of a valid input gpio"
		return 1
	}
}

check_position_string() {
	local position="$1"
	local str="$position"
	local prev

	while [ "x$str" != "x$prev" ]; do
		prev=$str

		str=${str%_hi}
		str=${str%_lo}
	done

	[ "x$str" = xhi ] || [ "x$str" = xlo ] || {
		warning "check_position_string: position \"$position\" is not in the format \"(hi|lo)(_(hi|lo))*\""
		return 1
	}
}

check_nonempty_string() {
	local str="$1"
	local str_name="$2"

	[ -n "$str" ] || {
		error "check_nonempty_string: $str_name cannot be an empty string"
		return 1
	}
}

check_safe_string() {
	local str="$1"
	local str_name="$2"

	[ -n "${str##*[!0-9A-Za-z_-]*}" ] || {
		error "check_safe_string: $str_name \"$str\" must contain letters, digits, underscores and/or hyphens only"
		return 1
	}
}

check_position_code() {
	local switch="$1"
	local position_name="$2"
	local codes="$3"
	local code

	get_position_code code "$switch" "$position_name"

	! list_contains "$codes" "$code" || {
		error "check_position_code: switch \"$switch\" cannot have both a position name \"$position_name\" and a code \"$code\""
		return 1
	}
}

validate_switch_data() {
	local switches
	local switch
	local labels_indices
	local label
	local codes
	local positions
	local position
	local position_name
	local i

	json_set_namespace switches
	json_select

	json_get_keys switches

	[ -n "$switches" ] || warning "validate_switch_data: no switches defined"

	for switch in $switches; do
		check_nonempty_string "$switch" "switch name" &&
		check_safe_string "$switch" "switch name" &&
		check_json_type "$switch" object || return

		json_select
		json_select "$switch"

		check_json_type labels array "$switch.labels" &&
		check_json_type codes array "$switch.codes" &&
		check_json_type positions object "$switch.positions" || return

		json_get_keys labels_indices labels
		json_get_values codes codes

		[ -n "$labels_indices" ] || warning "validate_switch_data: no labels defined for switch \"$switch\""
		[ -n "$codes" ] || warning "validate_switch_data: no codes defined for switch \"$switch\""

		json_select labels

		for i in $labels_indices; do
			json_get_var label "$i"
			check_input_gpio_label "$label" || return
		done

		json_select ..

		json_select positions

		json_get_keys positions

		[ -n "$positions" ] || warning "validate_switch_data: no positions defined for switch \"$switch\""

		for position in $positions; do
			check_position_string "$position" || continue

			check_json_type "$position" string "$switch.positions.$position" || return

			json_get_var position_name "$position"

			check_nonempty_string "$position_name" "position name" &&
			check_safe_string "$position_name" "position name" &&
			check_position_code "$switch" "$position_name" "$codes" || return
		done
	done
}

load_switch_data() {
	local board="$(board_name)"
	local type
	local data

	[ -f "$switches_cache" ] && {
		info "load_switch_data: loading switch data from $switches_cache"
		json_set_namespace switches
		json_load_file "$switches_cache"
		return
	}

	[ -n "$board" ] || {
		error "load_switch_data: missing board name"
		return $ex_dataerr
	}

	[ -f "$switch_data_file" ] || {
		error "load_switch_data: cannot find switch data file \"$switch_data_file\""
		return $ex_noinput
	}

	debug "load_switch_data: attempting to load switch data for $board from $switch_data_file"

	jsonfilter -q -i "$switch_data_file" -t "@" > /dev/null
	[ "$?" -ne 126 ] || {
		error "load_switch_data: failed to parse $switch_data_file"
		return $ex_dataerr
	}

	type=$(jsonfilter -i "$switch_data_file" -t "@[\"$board\"]")

	[ "x$type" = xstring ] && {
		debug "load_switch_data: $board shares switch data with another board, loading alternate board name"
		board=$(jsonfilter -i "$switch_data_file" -e "@[\"$board\"]")

		[ -n "$board" ] || {
			error "load_switch_data: missing alternate board name"
			return $ex_dataerr
		}

		type=$(jsonfilter -i "$switch_data_file" -t "@[\"$board\"]")
	}

	case $type in
		object)
			info "load_switch_data: loading switch data for $board from $switch_data_file"
			data=$(jsonfilter -i "$switch_data_file" -e "@[\"$board\"]")
			;;
		'')
			warning "load_switch_data: \"$board\" not found in $switch_data_file"
			return $ex_unavailable
			;;
		*)
			error "load_switch_data: \"$board\" is not an object in $switch_data_file"
			return $ex_dataerr
			;;
	esac

	json_set_namespace switches
	json_load "$data"

	validate_switch_data || return $ex_dataerr

	debug "load_switch_data: caching switch data to $switches_cache"
	mkdir -p "${switches_cache%/*}"
	echo "$data" > "$switches_cache"
}


get_switches() {
	local switches

	json_set_namespace switches
	json_select

	json_get_keys switches

	echo "$switches"
}

get_switch_for_button() {
	local button="$1"
	local switches
	local switch
	local codes

	json_set_namespace switches
	json_select

	json_get_keys switches

	for switch in $switches; do
		json_select
		json_select "$switch"

		json_get_values codes codes

		list_contains "$codes" "$button" && {
			debug "get_switch_for_button: found switch \"$switch\" for button \"$button\""
			echo "$switch"
			return
		}
	done

	debug "get_switch_for_button: no switches found for button \"$button\""
	return 1
}

get_current_position() {
	local switch="$1"
	local labels_indices
	local label
	local value
	local position
	local i

	json_set_namespace switches
	json_select
	json_select "$switch"
	json_select labels

	json_get_keys labels_indices

	for i in $labels_indices; do
		json_get_var label "$i"
		get_gpio_value value "$label" || return
		position="${position}_$value"
	done

	echo "${position#_}"
}

get_position_name() {
	local switch="$1"
	local position="$2"
	local position_name

	json_set_namespace switches
	json_select
	json_select "$switch"
	json_select positions

	json_get_var position_name "$position" || {
		warning "get_position_name: position \"$position\" for switch \"$switch\" does not have a position name"
		return 1
	}

	echo "$position_name"
}


get_state_file() {
	local switch="$1"

	echo "$state_dir/$switch"
}

init_state() {
	local switch="$1"
	local now
	local positions
	local position

	debug "init_state: initializing state for switch \"$switch\""

	json_set_namespace switches
	json_select
	json_select "$switch"

	json_get_keys positions positions

	get_epoch now || return
	position=$(get_current_position "$switch") || return
	debug "init_state: setting \"$position\" as initial position for switch \"$switch\""

	json_set_namespace state
	json_init

	json_add_string position "$position"

	json_add_object seen
	for position in $positions; do
		json_add_int "$position" "$now"
	done
	json_close_object
}

load_state() {
	local switch="$1"
	local state_file="$(get_state_file "$switch")"

	debug "load_state: attempting to load state for switch \"$switch\" from $state_file"

	[ -f "$state_file" ] && {
		debug "load_state: loading state from $state_file"
		json_set_namespace state
		json_load_file "$state_file"
	}
}

save_state() {
	local switch="$1"
	local state_file="$(get_state_file "$switch")"

	debug "save_state: saving state for switch \"$switch\" to $state_file"

	json_set_namespace state
	mkdir -p "${state_file%/*}"
	json_dump > "$state_file"
}


get_state_position() {
	local position

	json_set_namespace state
	json_select

	json_get_var position position

	echo "$position"
}

set_state_position() {
	local position="$1"

	json_set_namespace state
	json_select

	json_add_string position "$position"
}

get_state_seen() {
	local position="$1"
	local seen

	json_set_namespace state
	json_select
	json_select seen

	json_get_var seen "$position"

	echo "$seen"
}

set_state_seen() {
	local position="$1"
	local seen="$2"

	json_set_namespace state
	json_select
	json_select seen

	json_add_int "$position" "$seen"
}


get_lock_dir() {
	local switch="$1"

	echo "$lock_dir/$switch"
}

cleanup_locks() {
	local switch
	local dir

	for switch in $locks; do
		dir="$(get_lock_dir "$switch")"
		debug "cleanup_locks: attempting to remove $dir"
		[ -d "$dir" ] && {
			debug "cleanup_locks: removing $dir"
			rm -rf "$dir"
		}
	done

	locks=
}

get_lock() {
	local switch="$1"
	local dir="$(get_lock_dir "$switch")"

	mkdir -p "${dir%/*}"

	mkdir "$dir" 2>/dev/null || {
		debug "get_lock: failed to get lock for switch \"$switch\" ($dir)"
		return 1
	}

	locks="$locks $switch"

	trap 'cleanup_locks' EXIT
	trap 'cleanup_locks; trap - INT; kill -INT $$' INT
	trap 'exit 129' HUP
	trap 'exit 131' QUIT
	trap 'exit 143' TERM

	debug "get_lock: got lock for $switch ($dir)"
}

release_locks() {
	debug "release_locks: releasing locks"

	cleanup_locks

	trap - EXIT INT HUP QUIT TERM
}


trigger_button_event() {
	local switch="$1"
	local position="$2"
	local action="$3"
	local now="$4"
	local position_name="$(get_position_name "$switch" "$position")"
	local before
	local button
	local seen

	[ -n "$position_name" ] || {
		warning "trigger_button_event: could not get position name for switch \"$switch\" and position \"$position\""
		return 1
	}

	before=$(get_state_seen "$position")
	[ -n "$now" ] || now=$before
	set_state_seen "$position" "$now"

	get_position_code button "$switch" "$position_name"
	seen=$((now - before))

	notice "trigger_button_event: triggering button event with BUTTON=\"$button\" ACTION=\"$action\" SEEN=\"$seen\""

	(
		export BUTTON="$button"
		export ACTION="$action"
		export SEEN="$seen"

		debug "trigger_button_event: attempting to call $hotplug_call"
		[ -x "$hotplug_call" ] && "$hotplug_call" button

		debug "trigger_button_event: attempting to call $rc_button/$button"
		[ -x "$rc_button/$button" ] && "$rc_button/$button"
	)

	return 0
}


set_log() {
	local value="$1"

	case $value in
		none)   log_stderr= ; log_syslog=  ;;
		stderr) log_stderr=1; log_syslog=  ;;
		syslog) log_stderr= ; log_syslog=1 ;;
		all)    log_stderr=1; log_syslog=1 ;;

		*)      error "invalid log value \"$value\""; return $ex_usage ;;
	esac
}

set_verbosity() {
	local value="$1"

	log_level_to_num verbosity "$value" || {
		error "invalid verbosity value \"$value\""
		return $ex_usage
	}
}


do_init() {
	local force="$1"
	local switches
	local switch
	local position

	debug "init: do_init \"$force\""

	case $force in
		'')	debug "init: not forcing init" ;;
		force)	debug "init: forcing init" ;;
		*)	error "init: invalid option \"$force\""; return $ex_usage ;;
	esac

	load_switch_data || return

	switches=$(get_switches)

	for switch in $switches; do
		debug "init: attempting to init switch \"$switch\""

		[ "x$force" = "xforce" ] || ! load_state "$switch" || {
			debug "init: switch \"$switch\" already init"
			continue
		}

		get_lock "$switch" || continue

		init_state "$switch" || return

		position=$(get_state_position)
		trigger_button_event "$switch" "$position" pressed

		save_state "$switch"
		release_locks
	done
}

do_update() {
	local button="$1"
	local switches
	local switch
	local locked
	local now
	local current
	local previous

	debug "update: do_update \"$button\""

	load_switch_data || return

	if [ -n "$button" ]; then
		switches=$(get_switch_for_button "$button")
	else
		switches=$(get_switches)
	fi

	for switch in $switches; do
		get_lock "$switch" && locked="$locked $switch"
	done

	[ -n "$locked" ] || {
		debug "update: no switches to update"
		return
	}

	sleep 1

	get_epoch now || return

	for switch in $locked; do
		if load_state "$switch"; then
			previous=$(get_state_position)
			debug "update: previous position for switch \"$switch\" is \"$previous\""
		else
			init_state "$switch" || return
			previous=
			debug "update: no previous position for switch \"$switch\""
		fi

		current=$(get_current_position "$switch") || return
		debug "update: current position for switch \"$switch\" is \"$current\""

		[ "x$current" != "x$previous" ] || {
			debug "update: switch \"$switch\" position unchanged"
			continue
		}

		[ -n "$previous" ] && trigger_button_event "$switch" "$previous" released "$now"
		trigger_button_event "$switch" "$current" pressed "$now"

		set_state_position "$current"
		save_state "$switch"
	done

	release_locks
}

do_switch() {
	local switches

	load_switch_data || return

	switches=$(get_switches)

	echo "${switches# }"
}

do_position() {
	local requested="$1"
	local switches
	local switch
	local position
	local position_names

	debug "position: do_position \"$requested\""

	load_switch_data || return

	switches=$(get_switches)

	if [ -n "$requested" ]; then
		for switch in $requested; do
			list_contains "$switches" "$switch" || {
				error "position: \"$switch\" is not a valid switch"
				return $ex_usage
			}
		done
	else
		requested=$switches
	fi

	for switch in $requested; do
		position=$(get_current_position "$switch") || return
		position_names="$position_names $(get_position_name "$switch" "$position")"
	done

	echo "${position_names# }"
}

do_clean() {
	{
		rm -f "$switches_cache"

		rm -f "$state_dir"/*
		rmdir "$state_dir"

		rmdir "$lock_dir"/*

		rmdir "$run_dir" "$lock_dir"
	} 2>/dev/null

	return 0
}

do_boot() {
	local action="$1"

	debug "boot: do_boot \"$action\""

	[ -x "$initd_script" ] || {
		error "boot: init.d script \"$initd_script\" not found"
		return $ex_unavailable
	}

	case $action in
		enable)		debug "boot: enabling init on boot" ;;
		disable)	debug "boot: disabling init on boot" ;;
		*)		error "boot: invalid option \"$action\""; return $ex_usage ;;
	esac

	"$initd_script" "$action"
}

do_version() {
	echo "$package $version"
}
