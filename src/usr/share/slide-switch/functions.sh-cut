#
# src/usr/share/slide-switch/functions.sh-cut.in
# This file is part of slide-switch.
#
# Copyright (C) 2016-2019, 2022 The slide-switch authors
# https://github.com/jefferyto/openwrt-slide-switch
#
# slide-switch is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# version 2 as published by the Free Software Foundation.
#
# slide-switch is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with slide-switch.  If not, see <http://www.gnu.org/licenses/>.
#
# --8<---- CUT HERE
#
# Copyright (C) 2016-2019, 2022 The slide-switch authors
# https://github.com/jefferyto/openwrt-slide-switch
#
# slide-switch is free software, licensed under the GNU General Public License v2.
#

package=@PACKAGE@
version=@VERSION@

data_dir=@pkgdatadir@
run_dir=@localstatedir@/run/@PACKAGE@
lock_dir=@localstatedir@/lock/@PACKAGE@
initd_dir=@sysconfdir@/init.d

board_name=/tmp/sysinfo/board_name
gpio_table=/sys/kernel/debug/gpio
hotplug_call=/sbin/hotplug-call
rc_button=/etc/rc.button

switch_data_file=$data_dir/switch-data.json
switches_cache=$run_dir/switches
state_dir=$run_dir/state
initd_script=$initd_dir/zzz-slide-switch

. /usr/share/libubox/jshn.sh

me=${0##*/}

ex_usage=64
ex_dataerr=65
ex_noinput=66
ex_unavailable=69
ex_oserr=71

log_stderr=
log_syslog=
verbosity=
locks=


log_level_to_num() {
	local _var="$1"
	local _level="$2"
	local _num

	case $_level in
		emerg|panic)  _num=0 ;;
		alert)        _num=1 ;;
		crit)         _num=2 ;;
		err|error)    _num=3 ;;
		warning|warn) _num=4 ;;
		notice)       _num=5 ;;
		info)         _num=6 ;;
		debug)        _num=7 ;;

		*[!0-9]*)     return 1 ;;

		*)            _num=$_level ;;
	esac

	_set_var "$_var" "$_num"
}

log() {
	local level="$1"
	local message="$2"
	local level_num

	log_level_to_num level_num "$level" &&
	[ "$level_num" -le "$verbosity" ] || return 0

	[ -n "$log_stderr" ] && echo "[$level] $message" >&2

	[ -n "$log_syslog" ] && logger -t "${me}[$$]" -p "user.$level" "$message"

	return 0
}

error() {
	log err "$@"
}

warning() {
	log warning "$@"
}

notice() {
	log notice "$@"
}

info() {
	log info "$@"
}

debug() {
	log debug "$@"
}


get_board() {
	local _var="$1"
	local _board

	[ -e "$board_name" ] && _board=$(cat "$board_name") && _set_var "$_var" "$_board"
}

get_epoch() {
	local _var="$1"
	local _epoch

	_epoch=$(date +%s) || {
		error "get_epoch: failed to get date"
		return $ex_oserr
	}

	_set_var "$_var" "$_epoch"
}

list_contains() {
	local list=" $1 "
	local item=" $2 "

	[ -z "${list##*$item*}" ]
}

is_safe_string() {
	local str="$1"

	[ -n "${str##*[!0-9A-Za-z_-]*}" ]
}


get_gpio_value() {
	local __var="$1"
	local __label="$2"
	local __allow_no_matches="$3"
	local __pattern
	local __match
	local __result

	__pattern=$(printf '|%-20.20s) in  \(hi\|lo\)' "$__label") || {
		error "get_gpio_value: failed to get search pattern for label \"$__label\""
		return $ex_oserr
	}

	__match="$(grep -m 1 -o -e "$__pattern" "$gpio_table" 2>/dev/null)"
	__result=$?

	[ "$__result" -eq 0 ] || {
		[ "$__result" -eq 1 ] && {
			[ -z "$__allow_no_matches" ] && error "get_gpio_value: cannot find label \"$__label\" in $gpio_table"
			return $ex_dataerr
		}

		error "get_gpio_value: failed to search $gpio_table for label \"$__label\""
		return $ex_oserr
	}

	_set_var "$__var" "${__match##*) in  }"
}

get_position_code() {
	local _var="$1"
	local _switch="$2"
	local _position_name="$3"

	_set_var "$_var" "${_switch}-$_position_name"
}


check_json_type() {
	local key="$1"
	local type="$2"
	local key_name="${3:-$key}"
	local article="a"

	case $type in
		[aeiou]*) article=an ;;
	esac

	json_is_a "$key" "$type" || {
		error "check_json_type: \"$key_name\" is not $article $type in $switch_data_file"
		return $ex_dataerr
	}
}

check_nonempty_string() {
	local str="$1"
	local str_name="$2"

	[ -n "$str" ] || {
		error "check_nonempty_string: $str_name cannot be an empty string"
		return $ex_dataerr
	}
}

check_safe_string() {
	local str="$1"
	local str_name="$2"

	is_safe_string "$str" || {
		error "check_safe_string: $str_name \"$str\" must contain letters, digits, underscores and/or hyphens only"
		return $ex_dataerr
	}
}

check_input_gpio_label() {
	local label="$1"
	local value

	get_gpio_value value "$label" allow_no_matches && [ -n "$value" ] || {
		error "check_input_gpio_label: \"$label\" is not the label of a valid input gpio"
		return $ex_dataerr
	}
}

check_position_string() {
	local position="$1"
	local str="$position"
	local prev

	while [ "x$str" != "x$prev" ]; do
		prev=$str

		str=${str%_hi}
		str=${str%_lo}
	done

	[ "x$str" = xhi ] || [ "x$str" = xlo ] || {
		warning "check_position_string: position \"$position\" is not in the format \"(hi|lo)(_(hi|lo))*\""
		return $ex_dataerr
	}
}

check_position_code() {
	local switch="$1"
	local position_name="$2"
	local codes="$3"
	local code

	get_position_code code "$switch" "$position_name"

	! list_contains "$codes" "$code" || {
		error "check_position_code: switch \"$switch\" cannot have both a position name \"$position_name\" and a code \"$code\""
		return $ex_dataerr
	}
}

validate_switch_data() {
	local switches
	local switch
	local labels_indices
	local label
	local codes
	local positions
	local position
	local position_name
	local i

	json_set_namespace switches
	json_select

	json_get_keys switches

	[ -n "$switches" ] || warning "validate_switch_data: no switches defined"

	for switch in $switches; do
		check_nonempty_string "$switch" "switch name" &&
		check_safe_string "$switch" "switch name" &&
		check_json_type "$switch" object || return

		json_select
		json_select "$switch"

		check_json_type labels array "$switch.labels" &&
		check_json_type codes array "$switch.codes" &&
		check_json_type positions object "$switch.positions" || return

		json_get_keys labels_indices labels
		json_get_values codes codes
		json_get_keys positions positions

		[ -n "$labels_indices" ] || warning "validate_switch_data: no labels defined for switch \"$switch\""
		[ -n "$codes" ] || warning "validate_switch_data: no codes defined for switch \"$switch\""
		[ -n "$positions" ] || warning "validate_switch_data: no positions defined for switch \"$switch\""

		json_select labels

		for i in $labels_indices; do
			json_get_var label "$i"
			check_input_gpio_label "$label" || return
		done

		json_select ..
		json_select positions

		for position in $positions; do
			check_position_string "$position" || continue

			check_json_type "$position" string "$switch.positions.$position" || return

			json_get_var position_name "$position"

			check_nonempty_string "$position_name" "position name" &&
			check_safe_string "$position_name" "position name" &&
			check_position_code "$switch" "$position_name" "$codes" || return
		done
	done
}


load_switch_data_from_cache() {
	[ -f "$switches_cache" ] && [ -r "$switches_cache" ] || {
		debug "load_switch_data_from_cache: cannot read $switches_cache"
		return 1
	}

	info "load_switch_data_from_cache: loading switch data from $switches_cache"

	json_set_namespace switches
	json_load_file "$switches_cache"
}

save_switch_data_to_cache() {
	debug "save_switch_data_to_cache: caching switch data to $switches_cache"

	mkdir -p "${switches_cache%/*}"

	json_set_namespace switches
	json_select
	json_dump > "$switches_cache"
}

load_switch_data() {
	local no_load_from_cache="$1"
	local no_save_to_cache="$2"
	local board
	local type
	local data

	[ -z "$no_load_from_cache" ] && load_switch_data_from_cache && return

	get_board board && [ -n "$board" ] || {
		error "load_switch_data: missing board name"
		return $ex_dataerr
	}

	[ -f "$switch_data_file" ] || {
		error "load_switch_data: cannot find switch data file \"$switch_data_file\""
		return $ex_noinput
	}

	debug "load_switch_data: attempting to load switch data for $board from $switch_data_file"

	jsonfilter -q -i "$switch_data_file" -t "@" > /dev/null
	[ "$?" -ne 126 ] || {
		error "load_switch_data: failed to parse $switch_data_file"
		return $ex_dataerr
	}

	type=$(jsonfilter -i "$switch_data_file" -t "@[\"$board\"]")

	[ "x$type" = xstring ] && {
		debug "load_switch_data: $board shares switch data with another board, loading alternate board name"
		board=$(jsonfilter -i "$switch_data_file" -e "@[\"$board\"]")

		[ -n "$board" ] || {
			error "load_switch_data: missing alternate board name"
			return $ex_dataerr
		}

		type=$(jsonfilter -i "$switch_data_file" -t "@[\"$board\"]")
	}

	case $type in
		object)
			info "load_switch_data: loading switch data for $board from $switch_data_file"
			data=$(jsonfilter -i "$switch_data_file" -e "@[\"$board\"]")
			;;
		'')
			warning "load_switch_data: \"$board\" not found in $switch_data_file"
			return $ex_unavailable
			;;
		*)
			error "load_switch_data: \"$board\" is not an object in $switch_data_file"
			return $ex_dataerr
			;;
	esac

	json_set_namespace switches
	json_load "$data"

	validate_switch_data || return

	[ -z "$no_save_to_cache" ] && save_switch_data_to_cache

	return 0
}


get_switches() {
	local _var="$1"

	json_set_namespace switches
	json_select

	json_get_keys "$_var"
}

get_switch_for_button() {
	local _var="$1"
	local _button="$2"
	local _switches
	local _switch
	local _codes

	json_set_namespace switches
	json_select

	json_get_keys _switches

	for _switch in $_switches; do
		json_select
		json_select "$_switch"

		json_get_values _codes codes

		list_contains "$_codes" "$_button" && {
			debug "get_switch_for_button: found switch \"$_switch\" for button \"$_button\""
			_set_var "$_var" "$_switch"
			return
		}
	done

	debug "get_switch_for_button: no switches found for button \"$_button\""
	return 1
}

get_current_position() {
	local _var="$1"
	local _switch="$2"
	local _labels_indices
	local _label
	local _value
	local _position
	local _i

	json_set_namespace switches
	json_select
	json_select "$_switch"
	json_select labels

	json_get_keys _labels_indices

	for _i in $_labels_indices; do
		json_get_var _label "$_i"
		get_gpio_value _value "$_label" || return
		_position="${_position}_$_value"
	done

	_set_var "$_var" "${_position#_}"
}

get_position_name() {
	local _var="$1"
	local _switch="$2"
	local _position="$3"

	json_set_namespace switches
	json_select
	json_select "$_switch"
	json_select positions

	json_get_var "$_var" "$_position"
}


get_state_file() {
	local _var="$1"
	local _switch="$2"

	_set_var "$_var" "$state_dir/$_switch"
}

init_state() {
	local switch="$1"
	local now
	local positions
	local position

	debug "init_state: initializing state for switch \"$switch\""

	json_set_namespace switches
	json_select
	json_select "$switch"

	json_get_keys positions positions

	get_epoch now || return
	get_current_position position "$switch" || return
	debug "init_state: setting \"$position\" as initial position for switch \"$switch\""

	json_set_namespace state
	json_init

	json_add_string position "$position"

	json_add_object seen
	for position in $positions; do
		json_add_int "$position" "$now"
	done
	json_close_object
}

load_state() {
	local switch="$1"
	local state_file

	get_state_file state_file "$switch"

	debug "load_state: attempting to load state for switch \"$switch\" from $state_file"

	[ -f "$state_file" ] && {
		debug "load_state: loading state from $state_file"
		json_set_namespace state
		json_load_file "$state_file"
	}
}

save_state() {
	local switch="$1"
	local state_file

	get_state_file state_file "$switch"

	debug "save_state: saving state for switch \"$switch\" to $state_file"

	mkdir -p "${state_file%/*}"

	json_set_namespace state
	json_select
	json_dump > "$state_file"
}


get_state_position() {
	local _var="$1"

	json_set_namespace state
	json_select

	json_get_var "$_var" position
}

set_state_position() {
	local position="$1"

	json_set_namespace state
	json_select

	json_add_string position "$position"
}

get_state_seen() {
	local _var="$1"
	local _position="$2"

	json_set_namespace state
	json_select
	json_select seen

	json_get_var "$_var" "$_position"
}

set_state_seen() {
	local position="$1"
	local seen="$2"

	json_set_namespace state
	json_select
	json_select seen

	json_add_int "$position" "$seen"
}


get_lock_dir() {
	local _var="$1"
	local _switch="$2"

	_set_var "$_var" "$lock_dir/$_switch"
}

cleanup_locks() {
	local switch
	local switch_lock_dir

	for switch in $locks; do
		get_lock_dir switch_lock_dir "$switch"

		[ -d "$switch_lock_dir" ] || {
			warning "cleanup_locks: cannot find lock for switch \"$switch\" ($switch_lock_dir)"
			continue
		}

		debug "cleanup_locks: removing lock for switch \"$switch\" ($switch_lock_dir)"
		rmdir --ignore-fail-on-non-empty "$switch_lock_dir"
	done

	locks=
}

get_lock() {
	local switch="$1"
	local switch_lock_dir

	get_lock_dir switch_lock_dir "$switch"

	mkdir -p "${switch_lock_dir%/*}"

	mkdir "$switch_lock_dir" 2>/dev/null || {
		debug "get_lock: failed to get lock for switch \"$switch\" ($switch_lock_dir)"
		return 1
	}

	locks="$locks $switch"

	trap 'cleanup_locks' EXIT
	trap 'cleanup_locks; trap - INT; kill -INT $$' INT
	trap 'exit 129' HUP
	trap 'exit 131' QUIT
	trap 'exit 143' TERM

	debug "get_lock: got lock for $switch ($switch_lock_dir)"
}

release_locks() {
	debug "release_locks: releasing locks"

	cleanup_locks

	trap - EXIT INT HUP QUIT TERM
}


trigger_button_event() {
	local switch="$1"
	local position="$2"
	local action="$3"
	local now="$4"
	local position_name
	local before
	local button
	local seen

	get_position_name position_name "$switch" "$position"

	[ -n "$position_name" ] || {
		warning "trigger_button_event: could not get position name for switch \"$switch\" and position \"$position\""
		return 1
	}

	get_state_seen before "$position"
	[ -n "$now" ] || now=$before
	set_state_seen "$position" "$now"

	get_position_code button "$switch" "$position_name"
	seen=$((now - before))

	notice "trigger_button_event: triggering button event with BUTTON=\"$button\" ACTION=\"$action\" SEEN=\"$seen\""

	(
		export BUTTON="$button"
		export ACTION="$action"
		export SEEN="$seen"

		debug "trigger_button_event: attempting to call $hotplug_call"
		[ -x "$hotplug_call" ] && "$hotplug_call" button

		debug "trigger_button_event: attempting to call $rc_button/$button"
		[ -x "$rc_button/$button" ] && "$rc_button/$button"
	)

	return 0
}


set_log() {
	local value="$1"

	case $value in
		none)   log_stderr= ; log_syslog=  ;;
		stderr) log_stderr=1; log_syslog=  ;;
		syslog) log_stderr= ; log_syslog=1 ;;
		all)    log_stderr=1; log_syslog=1 ;;

		*)      error "invalid log value \"$value\""; return $ex_usage ;;
	esac
}

set_verbosity() {
	local value="$1"

	log_level_to_num verbosity "$value" || {
		error "invalid verbosity value \"$value\""
		return $ex_usage
	}
}


do_init() {
	local force="$1"
	local switches
	local switch
	local position

	debug "init: do_init \"$force\""

	case $force in
		'')	debug "init: not forcing init" ;;
		force)	debug "init: forcing init" ;;
		*)	error "init: invalid option \"$force\""; return $ex_usage ;;
	esac

	load_switch_data || return

	get_switches switches

	for switch in $switches; do
		debug "init: attempting to init switch \"$switch\""

		[ "x$force" = "xforce" ] || ! load_state "$switch" || {
			debug "init: switch \"$switch\" already init"
			continue
		}

		get_lock "$switch" || continue

		init_state "$switch" || return

		get_state_position position
		trigger_button_event "$switch" "$position" pressed

		save_state "$switch"
		release_locks
	done
}

do_update() {
	local button="$1"
	local switches
	local switch
	local locked
	local now
	local current
	local previous

	debug "update: do_update \"$button\""

	load_switch_data || return

	if [ -n "$button" ]; then
		get_switch_for_button switches "$button"
	else
		get_switches switches
	fi

	for switch in $switches; do
		get_lock "$switch" && locked="$locked $switch"
	done

	[ -n "$locked" ] || {
		debug "update: no switches to update"
		return
	}

	sleep 1

	get_epoch now || return

	for switch in $locked; do
		if load_state "$switch"; then
			get_state_position previous
			debug "update: previous position for switch \"$switch\" is \"$previous\""
		else
			init_state "$switch" || return
			previous=
			debug "update: no previous position for switch \"$switch\""
		fi

		get_current_position current "$switch" || return
		debug "update: current position for switch \"$switch\" is \"$current\""

		[ "x$current" != "x$previous" ] || {
			debug "update: switch \"$switch\" position unchanged"
			continue
		}

		[ -n "$previous" ] && trigger_button_event "$switch" "$previous" released "$now"
		trigger_button_event "$switch" "$current" pressed "$now"

		set_state_position "$current"
		save_state "$switch"
	done

	release_locks
}

do_switch() {
	local switches

	load_switch_data || return

	get_switches switches

	echo "${switches# }"
}

do_position() {
	local switch="$1"
	local switches
	local position
	local position_name

	load_switch_data '' no_save_to_cache || return

	get_switches switches

	[ -n "$switch" ] || {
		error "position: missing switch name"
		return $ex_usage
	}

	is_safe_string "$switch" || {
		error "position: \"$switch\" is not a valid switch name"
		return $ex_usage
	}

	list_contains "$switches" "$switch" || {
		error "position: cannot find switch \"$switch\""
		return $ex_usage
	}

	get_current_position position "$switch" || return
	get_position_name position_name "$switch" "$position"

	echo "$position_name"
}

do_clean() {
	{
		rm -f "$switches_cache"

		rm -f "$state_dir"/*
		rmdir "$state_dir"

		rmdir "$lock_dir"/*

		rmdir "$run_dir" "$lock_dir"
	} 2>/dev/null

	return 0
}

do_boot() {
	local action="$1"

	[ -x "$initd_script" ] || {
		error "boot: init.d script $initd_script not found or not executable"
		return $ex_unavailable
	}

	[ "x$action" = xenable ] || [ "x$action" = xdisable ] || {
		error "boot: invalid argument \"$action\""
		return $ex_usage
	}

	debug "boot: calling $initd_script $action"
	"$initd_script" "$action"
}

do_version() {
	echo "$me $version"
}
